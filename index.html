<!DOCTYPE html>
<html>
<head>
  <title>Advanced 3D Overlapping Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #0e0e0e; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial;
    }
  </style>
</head>
<body>

<div id="info">Move Mouse - Observe Overlapping & Follow Through</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer;
let segments = [];
let velocities = [];
let target = new THREE.Vector3();
const segmentCount = 20;
const stiffness = 0.15;  // Follow strength
const damping = 0.85;    // Smoothness

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x000000, 15, 50);

  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 20;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.PointLight(0xffffff, 1);
  light.position.set(10, 20, 10);
  scene.add(light);

  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);

  createChain();

  window.addEventListener("mousemove", onMouseMove);
  window.addEventListener("resize", onResize);
}

function createChain() {
  const geometry = new THREE.SphereGeometry(0.5, 32, 32);

  for (let i = 0; i < segmentCount; i++) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(`hsl(${i * 15}, 100%, 50%)`)
    });

    const segment = new THREE.Mesh(geometry, material);
    segment.position.x = -i;
    scene.add(segment);

    segments.push(segment);
    velocities.push(new THREE.Vector3());
  }
}

function onMouseMove(event) {
  const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

  target.x = mouseX * 10;
  target.y = mouseY * 6;
}

function updateChain() {
  for (let i = 0; i < segments.length; i++) {
    let current = segments[i];
    let goal;

    if (i === 0) {
      goal = target;
    } else {
      goal = segments[i - 1].position;
    }

    let direction = new THREE.Vector3().subVectors(goal, current.position);
    velocities[i].add(direction.multiplyScalar(stiffness));
    velocities[i].multiplyScalar(damping);
    current.position.add(velocities[i]);
  }
}

function animate() {
  requestAnimationFrame(animate);

  updateChain();

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
